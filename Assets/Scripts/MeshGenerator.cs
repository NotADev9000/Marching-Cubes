using System;
using System.Collections;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

[RequireComponent(typeof(NoiseGenerator)), RequireComponent(typeof(MeshFilter))]
public class MeshGenerator : MonoBehaviour
{
    private struct Triangle
    {
        public Vector3 a;
        public Vector3 b;
        public Vector3 c;

        public static int SizeOf => sizeof(float) * 3 * 3;
    }

    [SerializeField] private ComputeShader MarchingShader;

    [Space()]
    [Header("March Settings")]
    [SerializeField] private float _isoLevel = 0.5f;

    // Components:
    private NoiseGenerator _noiseGenerator;
    private MeshFilter _meshFilter;

    // Buffers:
    // holds the triangles that are generated by compute shader
    private ComputeBuffer _trianglesBuffer;
    // keeps track of how many triangles are generated by compute shader
    private ComputeBuffer _trianglesCountBuffer;
    // holds the noise values
    private ComputeBuffer _weightsBuffer;
    private float[] _weights;

    // Unity throws a fit if you try to call a compute shader from OnValidate so we need to do it in Update
    public bool SettingsUpdated { get; set; } = false;

    public float IsoLevel
    {
        get { return _isoLevel; }
        set
        {
            _isoLevel = value;
            SettingsUpdated = true;
        }
    }

    private void Awake()
    {
        _noiseGenerator = GetComponent<NoiseGenerator>();
        _meshFilter = GetComponent<MeshFilter>();

        CreateBuffers();
    }

    private void OnDestroy()
    {
        ReleaseBuffers();
    }

    private void Start()
    {
        Execute();
    }

    private void LateUpdate()
    {
        if (SettingsUpdated)
        {
            Execute();
            SettingsUpdated = false;
        }

    }

#if UNITY_EDITOR
    private void OnValidate()
    {
        if (EditorApplication.isPlaying)
            SettingsUpdated = true;
    }
#endif

    public void Execute()
    {
        _weights = _noiseGenerator.GetNoise();
        _meshFilter.sharedMesh = ConstructMesh();
    }

    private Mesh ConstructMesh()
    {
        MarchingShader.SetBuffer(0, "_Triangles", _trianglesBuffer);
        MarchingShader.SetBuffer(0, "_Weights", _weightsBuffer);

        MarchingShader.SetInt("_ChunkSize", GridMetrics.PointsPerChunk);
        MarchingShader.SetFloat("_IsoLevel", _isoLevel);

        _weightsBuffer.SetData(_weights);
        _trianglesBuffer.SetCounterValue(0);

        int numThreadGroups = Mathf.CeilToInt(GridMetrics.PointsPerChunk / GridMetrics.NumThreads);
        MarchingShader.Dispatch(
            0,
            numThreadGroups,
            numThreadGroups,
            numThreadGroups
        );

        Triangle[] triangles = new Triangle[ReadTriangleCount()];
        _trianglesBuffer.GetData(triangles);

        return CreateMeshFromTriangles(triangles);
    }

    private int ReadTriangleCount()
    {
        int[] triCount = { 0 };
        ComputeBuffer.CopyCount(_trianglesBuffer, _trianglesCountBuffer, 0);
        _trianglesCountBuffer.GetData(triCount);
        return triCount[0];
    }

    private Mesh CreateMeshFromTriangles(Triangle[] triangles)
    {
        // each triangle has 3 vertices so we need to multiply the amount of triangles by 3
        Vector3[] verts = new Vector3[triangles.Length * 3];
        int[] tris = new int[triangles.Length * 3];

        for (int i = 0; i < triangles.Length; i++)
        {
            int startIndex = i * 3;

            verts[startIndex] = triangles[i].a;
            verts[startIndex + 1] = triangles[i].b;
            verts[startIndex + 2] = triangles[i].c;

            tris[startIndex] = startIndex;
            tris[startIndex + 1] = startIndex + 1;
            tris[startIndex + 2] = startIndex + 2;
        }

        Mesh mesh = new();
        mesh.vertices = verts;
        mesh.triangles = tris;
        mesh.RecalculateNormals();
        return mesh;
    }

    private void CreateBuffers()
    {
        _trianglesBuffer = new ComputeBuffer(5 * (
                (GridMetrics.PointsPerChunk - 1) *
                (GridMetrics.PointsPerChunk - 1) *
                (GridMetrics.PointsPerChunk - 1)
            ), Triangle.SizeOf, ComputeBufferType.Append);
        // Debug.Log("Triangle buffer size: " + _trianglesBuffer.count);
        _trianglesCountBuffer = new ComputeBuffer(1, sizeof(uint), ComputeBufferType.Raw);
        // Debug.Log("Triangle count buffer size: " + _trianglesCountBuffer.count);
        _weightsBuffer = new ComputeBuffer(GridMetrics.PointsPerChunk * GridMetrics.PointsPerChunk * GridMetrics.PointsPerChunk, sizeof(float));
        // Debug.Log("Weights buffer size: " + _weightsBuffer.count);
    }

    private void ReleaseBuffers()
    {
        _trianglesBuffer.Release();
        _trianglesCountBuffer.Release();
        _weightsBuffer.Release();
    }

    #region DEBUG
#if UNITY_EDITOR

    [Space()]
    [Header("Debug")]
    [SerializeField] private bool _drawWeights = false;
    [SerializeField] private bool _drawContainer = true;

    private void OnDrawGizmos()
    {
        if (_weights == null || _weights.Length == 0)
            return;

        if (_drawContainer)
        {
            Gizmos.color = Color.white;
            Gizmos.DrawWireCube(Vector3.one * (GridMetrics.PointsPerChunk - 1) / 2f, Vector3.one * (GridMetrics.PointsPerChunk - 1));
        }

        if (_drawWeights)
        {
            for (int x = 0; x < GridMetrics.PointsPerChunk; x++)
            {
                for (int y = 0; y < GridMetrics.PointsPerChunk; y++)
                {
                    for (int z = 0; z < GridMetrics.PointsPerChunk; z++)
                    {
                        int index = x + GridMetrics.PointsPerChunk * (y + GridMetrics.PointsPerChunk * z);
                        float noiseValue = _weights[index];
                        Gizmos.color = Color.Lerp(Color.black, Color.white, noiseValue);
                        Gizmos.DrawCube(new Vector3(x, y, z), Vector3.one * .2f);
                    }
                }
            }
        }
    }

#endif
    #endregion
}
